// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reservation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelReservation = `-- name: CancelReservation :exec
DELETE FROM reservations
WHERE reservation_id = $1 AND user_id = $2
`

type CancelReservationParams struct {
	ReservationID int64 `json:"reservation_id"`
	UserID        int64 `json:"user_id"`
}

func (q *Queries) CancelReservation(ctx context.Context, arg CancelReservationParams) error {
	_, err := q.db.Exec(ctx, cancelReservation, arg.ReservationID, arg.UserID)
	return err
}

const listAvailableSeatsForShowtime = `-- name: ListAvailableSeatsForShowtime :many
SELECT seat_id, row, number, created_at
FROM seats
WHERE seat_id NOT IN (
  SELECT seat_id FROM reservations WHERE showtime_id = $1
)
ORDER BY row, number
`

func (q *Queries) ListAvailableSeatsForShowtime(ctx context.Context, showtimeID int32) ([]Seat, error) {
	rows, err := q.db.Query(ctx, listAvailableSeatsForShowtime, showtimeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.SeatID,
			&i.Row,
			&i.Number,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByShowtime = `-- name: ListReservationsByShowtime :many
SELECT r.reservation_id, r.user_id, r.showtime_id, r.seat_id, r.reserved_at, u.name, se.row, se.number
FROM reservations r
JOIN users u ON u.user_id = r.user_id
JOIN seats se ON se.seat_id = r.seat_id
WHERE r.showtime_id = $1
`

type ListReservationsByShowtimeRow struct {
	ReservationID int64     `json:"reservation_id"`
	UserID        int64     `json:"user_id"`
	ShowtimeID    int32     `json:"showtime_id"`
	SeatID        int32     `json:"seat_id"`
	ReservedAt    time.Time `json:"reserved_at"`
	Name          string    `json:"name"`
	Row           int32     `json:"row"`
	Number        int32     `json:"number"`
}

func (q *Queries) ListReservationsByShowtime(ctx context.Context, showtimeID int32) ([]ListReservationsByShowtimeRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByShowtime, showtimeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByShowtimeRow{}
	for rows.Next() {
		var i ListReservationsByShowtimeRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.UserID,
			&i.ShowtimeID,
			&i.SeatID,
			&i.ReservedAt,
			&i.Name,
			&i.Row,
			&i.Number,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByUser = `-- name: ListReservationsByUser :many
SELECT r.reservation_id, r.user_id, r.showtime_id, r.seat_id, r.reserved_at, s.start_time, m.title, se.row, se.number
FROM reservations r
JOIN showtimes s ON s.showtime_id = r.showtime_id
JOIN movies m ON m.movie_id = s.movie_id
JOIN seats se ON se.seat_id = r.seat_id
WHERE r.user_id = $1
ORDER BY s.start_time
`

type ListReservationsByUserRow struct {
	ReservationID int64            `json:"reservation_id"`
	UserID        int64            `json:"user_id"`
	ShowtimeID    int32            `json:"showtime_id"`
	SeatID        int32            `json:"seat_id"`
	ReservedAt    time.Time        `json:"reserved_at"`
	StartTime     pgtype.Timestamp `json:"start_time"`
	Title         string           `json:"title"`
	Row           int32            `json:"row"`
	Number        int32            `json:"number"`
}

func (q *Queries) ListReservationsByUser(ctx context.Context, userID int64) ([]ListReservationsByUserRow, error) {
	rows, err := q.db.Query(ctx, listReservationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReservationsByUserRow{}
	for rows.Next() {
		var i ListReservationsByUserRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.UserID,
			&i.ShowtimeID,
			&i.SeatID,
			&i.ReservedAt,
			&i.StartTime,
			&i.Title,
			&i.Row,
			&i.Number,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reserveSeat = `-- name: ReserveSeat :one
INSERT INTO reservations (user_id, showtime_id, seat_id)
VALUES ($1, $2, $3)
RETURNING reservation_id, user_id, showtime_id, seat_id, reserved_at
`

type ReserveSeatParams struct {
	UserID     int64 `json:"user_id"`
	ShowtimeID int32 `json:"showtime_id"`
	SeatID     int32 `json:"seat_id"`
}

func (q *Queries) ReserveSeat(ctx context.Context, arg ReserveSeatParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, reserveSeat, arg.UserID, arg.ShowtimeID, arg.SeatID)
	var i Reservation
	err := row.Scan(
		&i.ReservationID,
		&i.UserID,
		&i.ShowtimeID,
		&i.SeatID,
		&i.ReservedAt,
	)
	return i, err
}
